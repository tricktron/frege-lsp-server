module ch.fhnw.thga.TypeSignature where

import Interpreter.FregeInterpreter(Interpreter, InterpreterConfig, typeof, Message)
import Control.monad.trans.MonadIO(liftIO)
import Repl.FregeRepl(ReplResult, ReplEnv, Repl, Eval, Type, eval)
import Compiler.enums.Flags
import Compiler.Main as Compiler hiding (failed)
import Compiler.common.CompilerOptions (standardGlobal, stdOptions)
import  Control.Concurrent as C()
import Test.QuickCheck

data ArrayList a = native java.util.ArrayList where
  native add :: Mutable s (ArrayList a) -> a -> ST s Bool
  native new :: () -> STMutable s (ArrayList a)

  fromFregeList :: [a] -> STMutable s (ArrayList a)
  fromFregeList xs = ArrayList.new () >>= go xs where
    go :: [a] -> Mutable s (ArrayList a) -> STMutable s (ArrayList a)
    go [] list     = return list
    go (x:xs) list = ArrayList.add list x >> go xs list

initialReplEnv :: IO ReplEnv
initialReplEnv = do
  replEnv <- ReplEnv.initialState
  return replEnv.{config <- InterpreterConfig.{compilerFlags = Flags.fromList [WARNINGS, HINTS, INLINE, IDEMODE, IDETOKENS, MAKE]}}

evalFregeFile :: String -> ReplEnv -> IO (ReplResult, ReplEnv)
evalFregeFile file env = do
  (res, newEnv) <- Repl.run (eval $ Eval file) env
  return (res, newEnv)

getFunctionTypeSignature :: String -> ReplEnv -> IO (Maybe String, ReplEnv)
getFunctionTypeSignature fname env = Repl.run (evalType fname) env

evalType :: String -> Repl (Maybe String)
evalType expr = do
  env <- Repl.get
  res <- liftIO $ fst <$> Interpreter.run (typeof expr) env.config env.state
  case res of
    Left _     -> return Nothing
    Right typ -> return $ Just typ


simpleFregeModulePath :: String
simpleFregeModulePath = 
    "/Users/tricktron/github/master/frege-lsp-server/src/main/frege/ch/fhnw/thga/Test.fr"

fregeCompilerShouldEvaluateFile :: Property
fregeCompilerShouldEvaluateFile =
    once $ morallyDubiousIOProperty do
    mVar <- Compiler.compileFile stdOptions $ Right simpleFregeModulePath
    actual <- C.MVar.take mVar
    pure $ actual == True
