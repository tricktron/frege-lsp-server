module ch.fhnw.thga.TypeSignature where

import Interpreter.FregeInterpreter(Interpreter, InterpreterConfig, typeof, Message)
import Control.monad.trans.MonadIO(liftIO)
import Repl.FregeRepl(ReplResult, ReplEnv, Repl, Eval, Type, eval)
import Compiler.enums.Flags

data ArrayList a = native java.util.ArrayList where
  native add :: Mutable s (ArrayList a) -> a -> ST s Bool
  native new :: () -> STMutable s (ArrayList a)

  fromFregeList :: [a] -> STMutable s (ArrayList a)
  fromFregeList xs = ArrayList.new () >>= go xs where
    go :: [a] -> Mutable s (ArrayList a) -> STMutable s (ArrayList a)
    go [] list     = return list
    go (x:xs) list = ArrayList.add list x >> go xs list

initialReplEnv :: IO ReplEnv
initialReplEnv = do
  replEnv <- ReplEnv.initialState
  return replEnv.{config <- InterpreterConfig.{compilerFlags = Flags.fromList [WARNINGS, HINTS, INLINE, IDEMODE, IDETOKENS, MAKE]}}

evalFregeFile :: String -> ReplEnv -> IO (ReplResult, ReplEnv)
evalFregeFile file env = do
  (res, newEnv) <- Repl.run (eval $ Eval file) env
  return (res, newEnv)

getFunctionTypeSignature :: String -> ReplEnv -> IO (Maybe String, ReplEnv)
getFunctionTypeSignature fname env = Repl.run (evalType fname) env

evalType :: String -> Repl (Maybe String)
evalType expr = do
  env <- Repl.get
  res <- liftIO $ fst <$> Interpreter.run (typeof expr) env.config env.state
  case res of
    Left _     -> return Nothing
    Right typ -> return $ Just typ
