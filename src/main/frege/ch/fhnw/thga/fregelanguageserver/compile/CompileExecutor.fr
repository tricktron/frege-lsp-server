module ch.fhnw.thga.fregelanguageserver.compile.CompileExecutor where

import ch.fhnw.thga.fregelanguageserver.compile.CompileGlobal
import ch.fhnw.thga.fregelanguageserver.compile.CompileOptions(standardCompileOptions)
import Compiler.types.Global (
    Global, StIO, Message, StG, SubSt,
    liftIO, liftStG,getSTT, getST, forsome, stio, changeST
    )
import Compiler.common.CompilerOptions (standardGlobal, theClassLoader)
import Compiler.passes.Fix()
import Compiler.passes.Imp()
import Compiler.passes.Enter()
import Compiler.passes.Fields()
import Compiler.passes.TypeAlias()
import Compiler.passes.Instances()
import Compiler.passes.Transdef()
import Compiler.passes.LetUnroll as LU()
import Compiler.passes.GlobalLam as GL()
import Compiler.passes.Easy as EA()
import Compiler.passes.Strict as SC()
import Compiler.passes.Final as FI()
import Compiler.passes.GenCode()
import Compiler.GenMeta as GM()
import Compiler.Classes()
import Compiler.Typecheck as TC()
import Compiler.grammar.Lexer as L()
import Compiler.grammar.Frege as F()
import Compiler.enums.Flags
import Compiler.common.Desugar
import Compiler.types.Tokens
import Compiler.enums.TokenID
import Compiler.types.Packs
import Compiler.Main(Parsed, ParseMe, Todo, TodoList, openFilePrinter, closePrinter, javac, parseAll, successful, failed, addDepsOf, makeone, running, processDirs, createTodo, compiled)

import Control.monad.State (StateT, execStateT)
import Control.Concurrent as C()
import frege.Version(version)
import Data.TreeMap as TM(TreeMap, insert, delete, each, values)
import Test.QuickCheck (Property, once, morallyDubiousIOProperty)

instance Show Message where
  show msg = substr (show msg.level) 0 1 ++ " " ++ show msg.pos.first.tokid ++ show msg.pos.end ++ ": " ++ msg.text

passes = 
    [
        (liftStG Fix.pass,              "join definitions"),
        (Imp.pass,                      "import packages"),
        (liftStG (Classes.passI true),  "verify imported instances"),
        (liftStG Enter.pass,            "enter definitions"),
        (liftStG Fields.pass,           "field definitions"),
        (liftStG TypeAlias.pass,        "process type aliases"), 
        (liftStG (Instances.pass ()),   "derive and enter instances"),
        (Transdef.pass,                 "resolve names"),
        (liftStG Classes.passC,         "verify class definitions"),        -- TRACE6
        (liftStG $ Classes.passI false, "verify own instances"),            -- TRACE6
        (liftStG LU.pass,               "simplify lets"),                   -- TRACE7
        (TC.pass,                       "type check"),                      -- TRACET, TRACEO
        (liftStG EA.pass,               "simplify expressions"),            -- TRACE9
        (liftStG GL.pass,               "globalize anonymous lambdas"),     -- TRACE8
        (liftStG SC.pass,               "strictness analysis"),             -- TRACES
        (openPrinter,                   "open file"),
        (GM.genmeta,                    "generate meta data"),              -- none
        (GenCode.pass,                  "generate java code"),              -- TRACEG
        (closePrinter,                  "close java file"),
        (javac,                         "run java compiler"),
        (liftStG FI.cleanSymtab,        "clean up"),
    ]

openPrinter = do
    openFilePrinter ".java"
    GM.banner version
    return ("file", 1)

switchState :: Global -> StG Global
switchState new = do
    old <- getST
    StG.put new
    return old

lexParseSourceCode :: String -> StG Global
lexParseSourceCode fregeCode = do
    g  <- getST
    lexPassSourceCode fregeCode
    parsePass
    gc <- switchState g
    changeST _.{ sub <- _.{ numErrors <- (gc.errors +) } }
    return gc

lexPassSourceCode :: String -> StG (String, Int)
lexPassSourceCode fregeCode = do
    tokens <- L.passCS $ CharSequence.fromString fregeCode
    return ("tokens", length tokens)

parsePass :: StG (String, Int)
parsePass = do
    g      <- getST
    result <- F.pass (filter Token.noComment g.sub.toks.toList)
    case result of
        Just (Program.Module (packname, defs, doc)) -> do
            changeST Global.{
                sub <-  SubSt.{
                    thisPack   = Pack.new packname,
                    sourcedefs = defs,
                    packageDoc = doc
                }
            }
            when (isOn g.options.flags Flags.IDETOKENS) do
                changeST Global.{sub <- SubSt.{toks <- arrayFromList . ideClean . toList}}
            stio ("tokens",  g.sub.toks.length)
        nothing -> stio ("tokens", g.sub.toks.length)
    where
        -- prepare token list for IDE: no inserted semicolons and braces, operator qualifiers
        ideClean :: [Token] -> [Token]
        ideClean (t:ts)
            | t.tokid == COMMENT, t.value=="}" = ideClean ts
            | t.col   == 0                     = ideClean ts      -- inserted semicolon or brace
            | otherwise                        = t : ideClean ts
        ideClean []                            = []

private compileSourceCode :: String -> StIO Global
private compileSourceCode fregeCode = do
    lexParseState <- liftStG $ lexParseSourceCode fregeCode
    StateT.put lexParseState
    forsome passes runpass
    g <- getSTT
    return g

make :: C.MVar (Pack, Todo) -> TodoList -> StIO Global
make mvar tree = do
    -- go through the todo list and submit any tasks that can do some work
    tree <- foldM (makeone mvar) tree (each tree)
    -- if something was running before or just submitted, wait for an answer
    if any running (values tree)
    then do
        g       ←   getSTT
        tree    ←   liftIO do
            -- result <-  mvar.poll
            (p, todo)   ←   mvar.take
            --case result of
            --    Just x -> return x  -- no time for status
            --    _      -> do 
            --        status tree
            --        mvar.take
            --      where
            --        status tree = do
            --            let list = each tree
            --                rstate = filter (running    . snd) list
            --                fstate = filter (failed     . snd) list
            --                gstate = filter (successful . snd) list
            --            stderr.printf "%d running, %d failed, %d successful, %d queued/waiting%s"
            --                    (length rstate)
            --                    (length fstate)
            --                    (length gstate)
            --                    (length list - length rstate - length fstate - length gstate)
            --                    lineSeparator
            --            return () 
            -- let oldstate = maybe "WHAT THE FUCK???" show (tree.lookup p)

            when (isOn g.options.flags VERBOSE && successful todo || failed todo) do
                stderr.println (unmagicPack p.raw ++ ": " ++ show todo)

            case todo of
                CompileAfterDeps{global} -> do
                                -- need to add the new dependencies to the todo list
                                -- also, the package name may have changed
                                return ((     insert global.thisPack todo
                                            . delete p 
                                            . addDepsOf global) 
                                        tree)
                Waiting{for, status, todo=prev} -> do
                    -- module waited for may already have changed state,
                    -- in that case just resubmit
                    case tree.lookup for of
                        Just x | failed x || status x
                              = return (tree.insert p prev)
                        sonst = return (tree.insert p todo)
                _ | failed todo || successful todo
                              -- awake tasks waiting for this one 
                              = return (fmap unwait (tree.insert p todo))
                  | otherwise = return (tree.insert p todo)
                  where 
                        unwait Waiting{for, todo} | for == p = todo
                        unwait x = x
        make mvar tree
    else do                 -- no running tasks found
        liftIO C.shutdown

        -- -- javac the compiled stuff in case -j was given
        -- let javafs = [ targetPath global ".java" | Compiled{global} <- values tree,
        --                                             isOff global.options.flags RUNJAVAC ]
        -- g       ← getSTT
        -- changeSTT _.{options <- _.{flags <- flagSet RUNJAVAC}}
        -- unless (null javafs) do 
        --     start   ← liftIO $ System.currentTimeMillis ()
        --     javacs javafs
        --     ende    ← liftIO $ System.currentTimeMillis ()
        --     when (isOn g.options.flags VERBOSE) do 
        --         liftIO $ stderr.printf "java compilation of %d files took %5.3fs%s"
        --             (length javafs)
        --             ((ende.double - start.double) / 1000)
        --             (System.lineSeparator())
  
        if all successful (values tree)
        then do
            compileTodo = filter (compiled . snd) .each $ tree
            g <- getSTT 
            return g
        else do
            -- there should be no tasks that are not either successful or failed
            -- whenever this outputs something, it is time to reconsider the code
            let hanging = filter (not . successful . snd)
                        . filter (not . failed     . snd)
                        . each $ tree
            liftIO $ mapM_ (\(p,todo) -> stderr.println ("hanging: `" 
                            ++ unmagicPack p.raw ++ "`  "
                            ++ show todo)) hanging
            liftIO $ stderr.println "Build failed."
            getSTT

compileSourceCodeMake :: String -> StIO Global
compileSourceCodeMake fregeCode = do
    lexParseState <- liftStG $ lexParseSourceCode fregeCode
    --files <- processDirs [ fregeCode ]
    todos  = TreeMap.insert empty lexParseState.thisPack Parsed{global=lexParseState}
    mvar <- liftIO C.MVar.newEmpty
    todo <- parseAll mvar todos 
    g    <- make mvar todo
    return g

compile :: String -> Global -> IO Global
compile fregeCode = execStateT $ compileSourceCode fregeCode

compileMake :: String -> Global -> IO Global
compileMake fregeCode = execStateT $ compileSourceCodeMake fregeCode

runpass :: (StIO (String, Int), String) -> StIO ()
runpass (pass, description) = do
    state <- getSTT
    when (state.errors == 0) do
        (itemnm, items) <- pass
        return ()

shouldCorrectlyConfigureExtraClasspath :: Property
shouldCorrectlyConfigureExtraClasspath = once $ morallyDubiousIOProperty do
    fregeCodeWithDependency = 
        "module FregeFxDep where\n\n"++ 
        "import fregefx.JavaFxType\n\n" ++ 
        "main = println \"Hello FregeFX\""
    fregefxGlobal          <- CompileGlobal.fromOptions standardCompileOptions.
        {
            path = [ "./src/main/resources/fregefx-0.8.2-SNAPSHOT.jar" ]
        }
    actual                 <- compileMake fregeCodeWithDependency fregefxGlobal
    pure                    $ actual.errors == 0

main = do
    fregeCode      = "module FregeMakeModeTest where\n\n"
                  ++ "import Dep(square)\n\n"
                  ++ "frob a = square a"
    compileOptions = standardCompileOptions.{
        sourcePath = [ "/Users/tricktron/github/master/frege-lsp-server/src/main/resources" ]
    }
    global         <- CompileGlobal.fromOptions compileOptions
    compiledGlobal <- compileMake fregeCode global
    -- compiledGlobal <- compileMake "/Users/tricktron/github/master/frege-lsp-server/src/main/resources/FregeConcurrent.fr" global
    tokens              = listFromArray compiledGlobal.sub.toks
    for tokens println
    println $ CharSequence.toString compiledGlobal.sub.code
    println $ compiledGlobal.sub.nextPass
