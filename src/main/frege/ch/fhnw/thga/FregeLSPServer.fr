module ch.fhnw.thga.FregeLSPServer where

import Compiler.common.CompilerOptions (standardGlobal, stdOptions, theClassLoader)
import Compiler.types.Global (Global, StIO, liftIO, liftStG, Options, Message, getSTT, getST, changeSTT, StG, SubSt, forsome, stio)

import Control.monad.State
import frege.compiler.types.Targets public(thisTarget)
import frege.compiler.enums.Flags
import Compiler.types.Global (Global, StIO, liftIO, liftStG, Options, Message, getSTT, getST, changeSTT, StG, SubSt, forsome, stio, changeST, tokens)
import  Compiler.passes.Fix()
import  Compiler.passes.Imp()
import  Compiler.passes.Enter()
import  Compiler.passes.Fields()
import  Compiler.passes.TypeAlias()
import  Compiler.passes.Instances()
import  Compiler.passes.Transdef()
import  Compiler.passes.LetUnroll as LU()
import  Compiler.passes.GlobalLam as GL()
import  Compiler.passes.Easy as EA()
import  Compiler.passes.Strict    as SC()
import  Compiler.GenMeta   as GM()
import  Compiler.passes.GenCode()
import  Compiler.passes.Final as FI()
import  Compiler.Classes()
import  Compiler.Typecheck as TC()
import  Compiler.grammar.Lexer as L()
import  Compiler.grammar.Frege as F()


import  Compiler.enums.Flags
import  Compiler.common.Desugar
import  Compiler.common.CompilerOptions (thisTarget, standardGlobal, getOpts, theClassLoader, pathSep, ourPath)
import  Compiler.types.Tokens
import  Compiler.enums.TokenID
import  Compiler.types.Packs
import Compiler.Main(makepasses)

import  frege.compiler.types.Positions
import Test.QuickCheck (Property, once, morallyDubiousIOProperty, ==>, Testable)

data DiagnosticSeverity = ERROR | WARNING | INFORMATION | HINT

derive Eq DiagnosticSeverity
derive Show DiagnosticSeverity

data Position = Position {
    line      :: Int, -- 0 based
    character :: Int, -- 0 based character offset of a line
}

derive Eq Position
derive Show Position

data Range = Range {
    start :: Position,
    end   :: Position -- exclusive end
}

derive Eq Range
derive Show Range

data Diagnostic = Diagnostic {
    range    :: Range,
    severity :: DiagnosticSeverity,
    source   :: String,
    message  :: String
}

derive Eq Diagnostic
derive Show Diagnostic

instance Show Message where
  show msg = substr (show msg.level) 0 1 ++ " " ++ show msg.pos.first.tokid ++ show msg.pos.end ++ ": " ++ msg.text

lspOptions :: Options
lspOptions = Options { 
    source       = "-",
    sourcePath   = [ "." ],
    dir          = ".",
    path         = [],
    prefix       = "",
    encoding     = Just "UTF-8",
    tRanges      = [],
    target       = thisTarget,
    extending    = Nothing,
    implementing = [],
    code         = [],
    flags        = Flags.fromList
                 [
                   WARNINGS,
                   HINTS,
                   VERBOSE,
                   IDEMODE,
                   IDETOKENS
                 ]
}

passes = [
           (liftStG Fix.pass, "join definitions"),
           (Imp.pass, "import packages"),
           (liftStG (Classes.passI true), "verify imported instances"),
           (liftStG Enter.pass, "enter definitions"),
           (liftStG Fields.pass, "field definitions"),
           (liftStG TypeAlias.pass, "process type aliases"), 
           (liftStG (Instances.pass ()), "derive and enter instances"),
           (Transdef.pass, "resolve names"),
            (liftStG Classes.passC,          "verify class definitions"),        -- TRACE6
            (liftStG $ Classes.passI false,  "verify own instances"),            -- TRACE6
            (liftStG LU.pass,           "simplify lets"),                   -- TRACE7
            (TC.pass,                   "type check"),                      -- TRACET, TRACEO
            (liftStG EA.pass,          "simplify expressions"),            -- TRACE9
            (liftStG GL.pass,          "globalize anonymous lambdas"),     -- TRACE8
            (liftStG SC.pass,           "strictness analysis"),             -- TRACES
            (liftStG FI.cleanSymtab,  "clean up")
        ]

lspGlobal :: IO Global
lspGlobal = do
    initialLoader <- theClassLoader lspOptions
    initialGlobal <- standardGlobal
    pure initialGlobal. {
        options  = lspOptions,
        sub     <- SubSt. { loader = initialLoader }
    }

switchStateIO :: Global -> StIO Global
switchStateIO new = do
    old <- getSTT
    StateT.put new
    return old

switchState :: Global -> StG Global
switchState new = do
    old <- getST
    StG.put new
    return old

lexParseLSP :: String -> StG Global
lexParseLSP fregeCode = do
    g <- getST
    lexPassLSP fregeCode
    parsePass
    gc <- switchState g
    changeST _.{ sub <- _.{ numErrors <- (gc.errors +) } }
    return gc

lexPassLSP :: String -> StG (String, Int)
lexPassLSP fregeCode = do
    tokens <- L.passCS $ CharSequence.fromString fregeCode
    return ("tokens", length tokens)

parsePass :: StG (String, Int)
parsePass = do
    g      <- getST
    result <- F.pass (filter Token.noComment g.sub.toks.toList)
    case result of
        Just (Program.Module (packname, defs, doc)) -> do
            changeST Global.{
                sub <-  SubSt.{
                    thisPack   = Pack.new packname,
                    sourcedefs = defs,
                    packageDoc = doc
                }
            }
            when (isOn g.options.flags Flags.IDETOKENS) do
                changeST Global.{sub <- SubSt.{toks <- arrayFromList . ideClean . toList}}
            stio ("tokens",  g.sub.toks.length)
        nothing -> stio ("tokens", g.sub.toks.length)
    where
        -- prepare token list for IDE: no inserted semicolons and braces, operator qualifiers
        ideClean :: [Token] -> [Token]
        ideClean (t:ts)
            | t.tokid == COMMENT, t.value=="}" = ideClean ts
            | t.col == 0 = ideClean ts      -- inserted semicolon or brace
            | otherwise  = t : ideClean ts
        ideClean [] = []

compileFregeFile :: String -> StIO Global
compileFregeFile fregeCode = do
    lexParseState <- liftStG $ lexParseLSP fregeCode
    StateT.put lexParseState
    forsome passes runpass
    g <- getSTT
    return g

runpass :: (StIO (String, Int), String) -> StIO ()
runpass (pass, description) = do
    state <- getSTT
    when (state.errors == 0) do
        (itemnm, items) <- pass
        return ()

posToTokens :: [ Positions.Position ] -> Global -> [ Token ]
posToTokens [] _ = []
posToTokens (p:ps) gl = tokens p gl ++ posToTokens ps gl

tokensToRange :: [ Token ] -> Range
tokensToRange []     = Range { start = Position 0 0, end = Position 1 0 }
tokensToRange [ tk ] = Range
    {
        start = Position (tk.line - 1) tk.col,
        end   = Position (tk.line - 1) (tk.col + (length tk.value))
    }
tokensToRange tks    = 
    let
        startToken = head tks
        endToken   = last tks
    in
    Range 
    { 
        start = Position (startToken.line - 1) startToken.col,
        end   = Position (endToken.line - 1) (endToken.col + 1)  
    }

createRangeFromPos :: Positions.Position -> StG Range
createRangeFromPos pos = do
    gl <- getST
    toks = tokens pos gl
    pure $ tokensToRange toks

createDiagnosticFromMessage :: Message -> StG Diagnostic
createDiagnosticFromMessage message = do
    range <- createRangeFromPos message.pos
    pure $ Diagnostic 
        {
            range = range,
            severity = ERROR, 
            source = "frege compiler", 
            message = message.text
        }

extractDiagnostics :: StG [ Diagnostic ]
extractDiagnostics = do
    gl <- getST
    diagnostics = fmap createDiagnosticFromMessage gl.sub.messages
    sequence diagnostics

getDiagnostics :: String -> StIO [ Diagnostic ]
getDiagnostics fregeCode = do
    compileFregeFile fregeCode
    liftStG extractDiagnostics

getDummyDiagnostics :: [ Diagnostic ]
getDummyDiagnostics = 
    [ 
        Diagnostic 
        { 
                range = Range { start = Position 2 10, end = Position 2 11 }, 
                severity = ERROR, 
                source = "frege compiler", 
                message = "String is not an instance of num"
        }
    ]

fregeLSPServerShouldMapNoCompilerMessagesToEmptyArray :: Property
fregeLSPServerShouldMapNoCompilerMessagesToEmptyArray = once $ morallyDubiousIOProperty do
    fregeCodeWithoutError = "module CorrectFregeTest where\n\n" ++ "ok = 42 + 42"
    expected = []
    gl     <- lspGlobal
    actual <- evalStateT (getDiagnostics fregeCodeWithoutError) gl
    pure $ expected == actual

fregeLSPServerShouldMapSingleCompilerMessageToDiagnostics :: Property
fregeLSPServerShouldMapSingleCompilerMessageToDiagnostics = once $ morallyDubiousIOProperty do
    fregeCodeWithError = "module FaultyFregeTest where\n\n" ++ "err = 42 + \"42\""
    expected = 
        [ 
            Diagnostic 
            { 
                range = Range { start = Position 2 10, end = Position 2 11 }, 
                severity = ERROR, 
                source = "frege compiler", 
                message = "String is not an instance of Num" 
            } 
        ]
    gl     <- lspGlobal
    actual <- evalStateT (getDiagnostics fregeCodeWithError) gl
    pure $ expected == actual

fregeLSPServerShouldMapMultipleCompilerMessageToDiagnostics :: Property
fregeLSPServerShouldMapMultipleCompilerMessageToDiagnostics = once $ morallyDubiousIOProperty do
    fregeCodeWithErrors = "module ch.fhnw.thga.FaultyFregeTest where\n\nerr1 = do\n  x = 42\n\nerr2 = [ 22.0 ] ++ \"42\"\n\nerr3 = 42 + \"42\""
    expected = 
        [ 
            Diagnostic 
            { 
                range = Range { start = Position 5 20, end = Position 5 24 }, 
                severity = ERROR, 
                source = "frege compiler", 
                message = "type error in expression\n\"42\"\ntype is : String\nexpected: [t1]"
            },
            Diagnostic 
            { 
                range = Range { start = Position 7 11, end = Position 7 12 }, 
                severity = ERROR, 
                source = "frege compiler", 
                message = "String is not an instance of Num" 
            },
            Diagnostic 
            { 
                range = Range { start = Position 2 8, end = Position 2 10 }, 
                severity = ERROR, 
                source = "frege compiler", 
                message = "last statement in a monadic do block must not\nbe let decls" 
            }
        ]
    gl     <- lspGlobal
    actual <- evalStateT (getDiagnostics fregeCodeWithErrors) gl
    pure $ expected == actual


main :: IO ()
main = do
    initialLoader <- theClassLoader lspOptions
    initialGlobal <- standardGlobal
    let lspGlobal =  initialGlobal. {
        options  = lspOptions,
        sub     <- SubSt. { loader = initialLoader }
    }
    --let fregeCode     = "module ch.fhnw.thga.FaultyFregeTest where\n\nimport Does.not.Exist\n\nerr2 = [ 22.0 ] ++ \"42\""
    let fregeCode     = "module ch.fhnw.thga.FaultyFregeTest where\n\nerr1 = do\n  x = 42\n\nerr2 = [ 22.0 ] ++ \"42\"\n\nerr3 = 42 + \"42\""
    let testFregeCode = "module FaultyFregeTest where\n\n" ++ "err = 42 + \"42\""
    (res, gl) <- StateT.run (compileFregeFile fregeCode) lspGlobal
    println $ CharSequence.toString gl.sub.code
    for gl.sub.messages println
    let positions = map (Message.pos) gl.sub.messages
    let toks = posToTokens positions gl
    for toks println
