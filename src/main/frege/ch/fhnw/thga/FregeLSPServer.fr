module ch.fhnw.thga.FregeLSPServer where

import Compiler.common.CompilerOptions (standardGlobal, stdOptions, theClassLoader)
import Compiler.types.Global (Global, StIO, liftIO, liftStG, Options, Message, getSTT, getST, changeSTT, StG, SubSt, forsome, stio)

import Control.monad.State
import frege.compiler.types.Targets public(thisTarget)
import frege.compiler.enums.Flags
import Compiler.types.Global (Global, StIO, liftIO, liftStG, Options, Message, getSTT, getST, changeSTT, StG, SubSt, forsome, stio, changeST, tokens)
import  Compiler.passes.Fix()
import  Compiler.passes.Imp()
import  Compiler.passes.Enter()
import  Compiler.passes.Fields()
import  Compiler.passes.TypeAlias()
import  Compiler.passes.Transdef()
import  Compiler.passes.LetUnroll as LU()
import  Compiler.passes.GlobalLam as GL()
import  Compiler.passes.Easy as EA()
import  Compiler.passes.Strict    as SC()
import  Compiler.GenMeta   as GM()
import  Compiler.passes.GenCode()
import  Compiler.passes.Final as FI()
import  Compiler.Classes()
import  Compiler.Typecheck as TC()
import  Compiler.grammar.Lexer as L()
import  Compiler.grammar.Frege as F()


import  Compiler.enums.Flags
import  Compiler.common.Desugar
import  Compiler.common.CompilerOptions (thisTarget, standardGlobal, getOpts, theClassLoader, pathSep, ourPath)
import  Compiler.types.Tokens
import  Compiler.enums.TokenID
import  Compiler.types.Packs
import Compiler.Main(makepasses)

import  frege.compiler.types.Positions
import Test.QuickCheck (Property, once, morallyDubiousIOProperty, ==>, Testable)

data DiagnosticSeverity = ERROR | WARNING | INFORMATION | HINT

derive Eq DiagnosticSeverity

data Position = Position {
    line      :: Int, -- 0 based
    character :: Int, -- 0 based character offset of a line
}

derive Eq Position

data Range = Range {
    start :: Position,
    end   :: Position -- exclusive end
}

derive Eq Range

data Diagnostic = Diagnostic {
    range    :: Range,
    severity :: DiagnosticSeverity,
    source   :: String,
    message  :: String
}

derive Eq Diagnostic

instance Show Message where
  show msg = substr (show msg.level) 0 1 ++ " " ++ show msg.pos.first.tokid ++ show msg.pos.end ++ ": " ++ msg.text

lspOptions :: Options
lspOptions = Options { 
    source       = "-",
    sourcePath   = [ "." ],
    dir          = ".",
    path         = [],
    prefix       = "",
    encoding     = Just "UTF-8",
    tRanges      = [],
    target       = thisTarget,
    extending    = Nothing,
    implementing = [],
    code         = [],
    flags        = Flags.fromList
                 [
                   WARNINGS,
                   HINTS,
                   VERBOSE,
                   IDEMODE,
                   IDETOKENS
                 ]
}

lspGlobal :: IO Global
lspGlobal = do
    initialLoader <- theClassLoader lspOptions
    initialGlobal <- standardGlobal
    pure initialGlobal. {
        options  = lspOptions,
        sub     <- SubSt. { loader = initialLoader }
    }

switchStateIO :: Global -> StIO Global
switchStateIO new = do
    old <- getSTT
    StateT.put new
    return old

switchState :: Global -> StG Global
switchState new = do
    old <- getST
    StG.put new
    return old

lexParseLSP :: String -> StG Global
lexParseLSP fregeCode = do
    g <- getST
    lexPassLSP fregeCode
    parsePass
    gc <- switchState g
    changeST _.{ sub <- _.{ numErrors <- (gc.errors +) } }
    return gc

lexPassLSP :: String -> StG (String, Int)
lexPassLSP fregeCode = do
    tokens <- L.passCS $ CharSequence.fromString fregeCode
    return ("tokens", length tokens)

parsePass :: StG (String, Int)
parsePass = do
    g      <- getST
    result <- F.pass (filter Token.noComment g.sub.toks.toList)
    case result of
        Just (Program.Module (packname, defs, doc)) -> do
            changeST Global.{
                sub <-  SubSt.{
                    thisPack   = Pack.new packname,
                    sourcedefs = defs,
                    packageDoc = doc
                }
            }
            when (isOn g.options.flags Flags.IDETOKENS) do
                changeST Global.{sub <- SubSt.{toks <- arrayFromList . ideClean . toList}}
            stio ("tokens",  g.sub.toks.length)
        nothing -> stio ("tokens", g.sub.toks.length)
    where
        -- prepare token list for IDE: no inserted semicolons and braces, operator qualifiers
        ideClean :: [Token] -> [Token]
        ideClean (t:ts)
            | t.tokid == COMMENT, t.value=="}" = ideClean ts
            | t.col == 0 = ideClean ts      -- inserted semicolon or brace
            | otherwise  = t : ideClean ts
        ideClean [] = []

compileFregeFile :: String -> StIO Global
compileFregeFile fregeCode = do
    lexParseState <- liftStG $ lexParseLSP fregeCode
    StateT.put lexParseState
    forsome makepasses runpass
    g <- getSTT
    return g

runpass :: (StIO (String, Int), String) -> StIO ()
runpass (pass, description) = do
    state <- getSTT
    when (state.errors == 0) do
        (itemnm, items) <- pass
        return ()

posToTokens :: [ Positions.Position ] -> Global -> [ Token ]
posToTokens [] _ = []
posToTokens (p:ps) gl = tokens p gl ++ posToTokens ps gl

fregeLSPServerShouldMapCompilerMessgesToDiagnostics :: Property
fregeLSPServerShouldMapCompilerMessgesToDiagnostics = once $ morallyDubiousIOProperty do
    fregeCodeWithError = "module FaultyFregeTest where\n\n" ++ "err = 42 + \"42\""
    expected = 
        [ 
            Diagnostic 
            { 
                range = Range { start = Position 2 10, end = Position 2 11 }, 
                severity = ERROR, 
                source = "frege compiler", 
                message = "String is not an instance of num" 
            } 
        ]
    gl <- lspGlobal
    (actual, _) <- StateT.run (getDiagnostics fregeCodeWithError) gl
    pure $ expected == actual

createRangeFromPos :: Global -> Positions.Position -> Range
createRangeFromPos gl pos = 
    let 
        toks = tokens pos gl
    in
        tokensToRange toks where
            -- tokensToRange :: [ Token ] -> Range
            tokensToRange []  = Range { start = Position 0 0, end = Position 1 0 }
            tokensToRange tks = 
                let
                    startToken = head tks
                    endToken   = last tks
                in
                    Range { start = Position (startToken.line - 1) startToken.col,
                            end   = Position (endToken.line - 1) (endToken.col + 1)  
                    }


createDiagnosticFromMessage :: Global -> Message -> Diagnostic
createDiagnosticFromMessage gl message = Diagnostic 
    {
        range = createRangeFromPos gl message.pos,
        severity = ERROR, 
        source = "frege compiler", 
        message = "String is not an instance of num" 
    }

extractDiagnostics :: Global -> [ Diagnostic ]
extractDiagnostics global = 
    let 
        firstMessage = head global.sub.messages
    in  
    [ 
        createDiagnosticFromMessage global firstMessage
    ]

getDiagnostics :: String -> StIO [ Diagnostic ]
getDiagnostics fregeCode = do
    g <- compileFregeFile fregeCode
    pure $ extractDiagnostics g

getDummyDiagnostics :: [ Diagnostic ]
getDummyDiagnostics = 
    [ 
        Diagnostic 
        { 
                range = Range { start = Position 2 10, end = Position 2 11 }, 
                severity = ERROR, 
                source = "frege compiler", 
                message = "String is not an instance of num" 
        }
    ]


main :: IO ()
main = do
    initialLoader <- theClassLoader lspOptions
    initialGlobal <- standardGlobal
    let lspGlobal =  initialGlobal. {
        options  = lspOptions,
        sub     <- SubSt. { loader = initialLoader }
    }
    let fregeCode     = "module ch.fhnw.thga.FaultyFregeTest where\n\nerr = [ 22.0 ] ++ \"42\"\n\nok = 22 + 55"
    let testFregeCode = "module FaultyFregeTest where\n\n" ++ "err = 42 + \"42\""
    (res, gl) <- StateT.run (compileFregeFile testFregeCode) lspGlobal
    println $ CharSequence.toString gl.sub.code
    for gl.sub.messages println
    let positions = map (Message.pos) gl.sub.messages
    let toks = posToTokens positions gl
    for toks println
