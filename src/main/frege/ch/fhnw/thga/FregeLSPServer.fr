module ch.fhnw.thga.FregeLSPServer where

import Compiler.common.CompilerOptions (standardGlobal, stdOptions, theClassLoader)
import Compiler.types.Global (Global, StIO, liftIO, liftStG, Options, Message, getSTT, getST, changeSTT, StG, SubSt, forsome, stio)

import Control.monad.State
import frege.compiler.types.Targets public(thisTarget)
import frege.compiler.enums.Flags
import Compiler.types.Global (Global, StIO, liftIO, liftStG, Options, Message, getSTT, getST, changeSTT, StG, SubSt, forsome, stio, changeST, tokens)
import  Compiler.passes.Fix()
import  Compiler.passes.Imp()
import  Compiler.passes.Enter()
import  Compiler.passes.Fields()
import  Compiler.passes.TypeAlias()
import  Compiler.passes.Transdef()
import  Compiler.passes.LetUnroll as LU()
import  Compiler.passes.GlobalLam as GL()
import  Compiler.passes.Easy as EA()
import  Compiler.passes.Strict    as SC()
import  Compiler.GenMeta   as GM()
import  Compiler.passes.GenCode()
import  Compiler.passes.Final as FI()
import  Compiler.Classes()
import  Compiler.Typecheck as TC()
import  Compiler.grammar.Lexer as L()
import  Compiler.grammar.Frege as F()


import  Compiler.enums.Flags
import  Compiler.common.Desugar
import  Compiler.common.CompilerOptions (thisTarget, standardGlobal, getOpts, theClassLoader, pathSep, ourPath)
import  Compiler.types.Tokens
import  Compiler.enums.TokenID
import  Compiler.types.Packs
import Compiler.Main(makepasses)

import  frege.compiler.types.Positions
import Test.QuickCheck (Property, once, morallyDubiousIOProperty, ==>, Testable)

data DiagnosticSeverity = ERROR | WARNING | INFORMATION | HINT

derive Eq DiagnosticSeverity
derive Show DiagnosticSeverity

data Position = Position {
    line      :: Int, -- 0 based
    character :: Int, -- 0 based character offset of a line
}

derive Eq Position
derive Show Position

data Range = Range {
    start :: Position,
    end   :: Position -- exclusive end
}

derive Eq Range
derive Show Range

data Diagnostic = Diagnostic {
    range    :: Range,
    severity :: DiagnosticSeverity,
    source   :: String,
    message  :: String
}

derive Eq Diagnostic
derive Show Diagnostic

instance Show Message where
  show msg = substr (show msg.level) 0 1 ++ " " ++ show msg.pos.first.tokid ++ show msg.pos.end ++ ": " ++ msg.text

lspOptions :: Options
lspOptions = Options { 
    source       = "-",
    sourcePath   = [ "." ],
    dir          = ".",
    path         = [],
    prefix       = "",
    encoding     = Just "UTF-8",
    tRanges      = [],
    target       = thisTarget,
    extending    = Nothing,
    implementing = [],
    code         = [],
    flags        = Flags.fromList
                 [
                   WARNINGS,
                   HINTS,
                   VERBOSE,
                   IDEMODE,
                   IDETOKENS
                 ]
}

lspGlobal :: IO Global
lspGlobal = do
    initialLoader <- theClassLoader lspOptions
    initialGlobal <- standardGlobal
    pure initialGlobal. {
        options  = lspOptions,
        sub     <- SubSt. { loader = initialLoader }
    }

switchStateIO :: Global -> StIO Global
switchStateIO new = do
    old <- getSTT
    StateT.put new
    return old

switchState :: Global -> StG Global
switchState new = do
    old <- getST
    StG.put new
    return old

lexParseLSP :: String -> StG Global
lexParseLSP fregeCode = do
    g <- getST
    lexPassLSP fregeCode
    parsePass
    gc <- switchState g
    changeST _.{ sub <- _.{ numErrors <- (gc.errors +) } }
    return gc

lexPassLSP :: String -> StG (String, Int)
lexPassLSP fregeCode = do
    tokens <- L.passCS $ CharSequence.fromString fregeCode
    return ("tokens", length tokens)

parsePass :: StG (String, Int)
parsePass = do
    g      <- getST
    result <- F.pass (filter Token.noComment g.sub.toks.toList)
    case result of
        Just (Program.Module (packname, defs, doc)) -> do
            changeST Global.{
                sub <-  SubSt.{
                    thisPack   = Pack.new packname,
                    sourcedefs = defs,
                    packageDoc = doc
                }
            }
            when (isOn g.options.flags Flags.IDETOKENS) do
                changeST Global.{sub <- SubSt.{toks <- arrayFromList . ideClean . toList}}
            stio ("tokens",  g.sub.toks.length)
        nothing -> stio ("tokens", g.sub.toks.length)
    where
        -- prepare token list for IDE: no inserted semicolons and braces, operator qualifiers
        ideClean :: [Token] -> [Token]
        ideClean (t:ts)
            | t.tokid == COMMENT, t.value=="}" = ideClean ts
            | t.col == 0 = ideClean ts      -- inserted semicolon or brace
            | otherwise  = t : ideClean ts
        ideClean [] = []

compileFregeFile :: String -> StIO Global
compileFregeFile fregeCode = do
    lexParseState <- liftStG $ lexParseLSP fregeCode
    StateT.put lexParseState
    forsome makepasses runpass
    g <- getSTT
    return g

runpass :: (StIO (String, Int), String) -> StIO ()
runpass (pass, description) = do
    state <- getSTT
    when (state.errors == 0) do
        (itemnm, items) <- pass
        return ()

posToTokens :: [ Positions.Position ] -> Global -> [ Token ]
posToTokens [] _ = []
posToTokens (p:ps) gl = tokens p gl ++ posToTokens ps gl

fregeLSPServerShouldMapCompilerMessgesToDiagnostics :: Property
fregeLSPServerShouldMapCompilerMessgesToDiagnostics = once $ morallyDubiousIOProperty do
    fregeCodeWithError = "module FaultyFregeTest where\n\n" ++ "err = 42 + \"42\""
    expected = 
        [ 
            Diagnostic 
            { 
                range = Range { start = Position 2 10, end = Position 2 11 }, 
                severity = ERROR, 
                source = "frege compiler", 
                message = "String is not an instance of num" 
            } 
        ]
    gl <- lspGlobal
    -- actual = getDummyDiagnostics
    (actual, _) <- StateT.run (getDiagnostics fregeCodeWithError) gl
    println $ show actual
    pure $ expected == actual

createRangeFromPos :: Positions.Position -> StG Range
createRangeFromPos pos = do
    gl <- getST
    toks = tokens pos gl
    pure $ tokensToRange toks where
        -- tokensToRange :: [ Token ] -> Range
        tokensToRange []  = Range { start = Position 0 0, end = Position 1 0 }
        -- tokensToRange [ x ] =  
        tokensToRange tks = 
            let
                startToken = head tks
                endToken   = last tks
            in
                Range { start = Position (startToken.line - 1) startToken.col,
                        end   = Position (endToken.line - 1) (endToken.col + 1)  
                }


createDiagnosticFromMessage :: Message -> StG Diagnostic
createDiagnosticFromMessage message = do
    gl <- getST
    pure $ Diagnostic 
        {
            range = State.evalState (createRangeFromPos message.pos) gl,
            severity = ERROR, 
            source = "frege compiler", 
            message = "String is not an instance of num" 
        }

extractDiagnostics :: StG [ Diagnostic ]
extractDiagnostics = do
    gl <- getST
    firstMessage = head gl.sub.messages  
    pure $ [ State.evalState (createDiagnosticFromMessage firstMessage) gl ]

getDiagnostics :: String -> StIO [ Diagnostic ]
getDiagnostics fregeCode = do
    compileFregeFile fregeCode
    liftStG extractDiagnostics

getDummyDiagnostics :: [ Diagnostic ]
getDummyDiagnostics = 
    [ 
        Diagnostic 
        { 
                range = Range { start = Position 2 10, end = Position 2 11 }, 
                severity = ERROR, 
                source = "frege compiler", 
                message = "String is not an instance of num" 
        }
    ]


main :: IO ()
main = do
    initialLoader <- theClassLoader lspOptions
    initialGlobal <- standardGlobal
    let lspGlobal =  initialGlobal. {
        options  = lspOptions,
        sub     <- SubSt. { loader = initialLoader }
    }
    let fregeCode     = "module ch.fhnw.thga.FaultyFregeTest where\n\nerr = [ 22.0 ] ++ \"42\"\n\nok = 22 + 55"
    let testFregeCode = "module FaultyFregeTest where\n\n" ++ "err = 42 + \"42\""
    (res, gl) <- StateT.run (compileFregeFile testFregeCode) lspGlobal
    println $ CharSequence.toString gl.sub.code
    for gl.sub.messages println
    let positions = map (Message.pos) gl.sub.messages
    let toks = posToTokens positions gl
    for toks println
