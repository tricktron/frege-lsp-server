ifdef::env-vscode[:imagesdir: ../assets/images]
:xrefstyle: short
= Constraints

The following constraints are imposed upon the Frege IDE:

== Language Server Protocol (LSP)
xref:quality-attributes.adoc#_interoperability[Interoperability] is the Frege IDE's highest priority quality attribute and it can only be satisfied if the communication between the text editor and the Frege IDE is standardized. The https://microsoft.github.io/language-server-protocol/[LSP] emerged as the communication standard. As a result, the Frege IDE must implement the LSP.

The LSP uses a client-server model with a remote procedure call JSON (JSON-RPC) message format and supports standard input output, pipes and sockets as communication channels. The text editor takes the role of the client while
the Frege IDE acts as the server. The protocol consists of a header and a content part and specifies three types of messsages:

Notification:: which does not require a response.
Request:: which requires a response.
Response:: which matches a request.

Hence, every supported interaction is either started by a notification or request message. 

<<diag-lsp-seq>> shows the exchanged messages when the user opens a Frege file:

.The user opens a Frege file in the text editor which initialises the Frege IDE first. Since the initialize message is a request, it requires a response. Afterwards the didOpen notification is sent to the Frege IDE. Since it is a notification, it does not require a response. However, the Frege IDE uses this moment to compile the openend Frege file and reports back any warnings and errors as diagnostics to the text editor.
[seqdiag#diag-lsp-seq]
....
seqdiag {
    edge_length = 500;
    default_fontsize = 16;
    "Text Editor" ->  "Frege IDE" [ label = "request initialize" ];
    "Text Editor" <-- "Frege IDE" [ label = "response initialized" ];
    "Text Editor" ->>  "Frege IDE" [ label = "textDocument/didOpen notification" ];
    "Text Editor" <<- "Frege IDE" [ label = "textDocument/publishDiagnostics notification" ];
}
....

<<json-rpc-lsp>> shows the JSON-RPC message of the `textDocument/publishDiagnostics` notification from <<diag-lsp-seq>>.

.The JSON shows the JSON-RPC message of the `textDocument/publishDiagnostics` notification from <<diag-lsp-seq>>.
[source#json-rpc-lsp,json]
----
Content-Length: ...\r\n
\r\n
{
    "jsonrpc": "2.0",
    "id": 4,
    "method": "textDocument/publishDiagnostics",
    "params": {
        "uri": "file:///Users/.../Hello.fr",
        "diagnostics": [
            {
                "range": {
                    "start": {
                        "line": 5,
                        "character": 8
                    },
                    "end": {
                        "line": 5,
                        "character": 19
                    }
                },
                "severity": 3,
                "source": "frege compiler",
                "message": "value `result` is not used anywhere."
            }
        ]
    }
}
----

The https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/[LSP specification] divides the supported messages into the following groups which are summarized for brevity:

Lifecycle Messages:: signal the start and exit of the client-server interaction. Examples are `intialize` and `shutdown`.
Document Synchronization:: signals document specific messages such as `didOpen`, `didChange` and `didSave`. Documents with a corresponding URI are the basic units for files and folders.
Language Features:: are language specific code smarts visualised by the text editor which help developers to write code faster. Examples are `Goto Declaration`, `Hover` and `PublishDiagnostics`.
Workspace Features:: A workspace is an opened project in a text editor with one or more root folders. Example messages are `didChangeWatchedFiles`, `workspaceSymbol` and `didChangeConfiguration`.
Window Features:: are messages related to the user interface such as `ShowMessage` and `Create Work Done Progress`.

[NOTE]
.Document Ownership and its Single Source of Truth
====
The `didOpen` notification transfers the ownership of the document to the text editor by loading it into a buffer. As a result, the document's single source of truth lies now in the text editor's buffer and not on the file system anymore. The `didChange notification` propagates changes on the buffer to the server. The single source of truth is only synced to the file system after the `didSave` notification. As a consequence, a server *should not* read the document from filesystem between the `didOpen` and `didSave` notification. If the server needs to read from the filesystem it should use the `didChangeWatchedFiles` instead of the `didChange` notification.
====

[#lsp4j]
== Language Server Protocol 4 Java (LSP4J)
There are existing https://microsoft.github.io/language-server-protocol/implementors/sdks/[software development kits (SDKs)] which provide language bindings for the LSP types, the JSON-RPC format and its asychronous message exchange. Implementing the LSP myself in Frege was out of scope and therefore we use the https://github.com/eclipse/lsp4j[LSP4J] library for the Frege IDE.

https://github.com/eclipse/lsp4j/blob/main/documentation/README.md[After setting up LSP4J], we only need to implement the `org.eclipse.lsp4j.services.LanguageServer`, `org.eclipse.lsp4j.services.LanguageServer.TextDocumentService` and `org.eclipse.lsp4j.services.WorkspaceService` interfaces. <<code-lsp4j-hover>> shows and explains how LSP4J works and helps with an example of the hover language feature.

.The Hover Feature with LSP4J
[source#code-lsp4j-hover,java]
----
class FregeTextDocumentService implements TextDocumentService
{
    ...
    @Override
    public CompletableFuture<Hover> hover(HoverParams params) // <1>
    {
        return HoverService.hover(params); // <2>
    }
    ...
}
----
<1> LSP4J provides the `CompletableFuture` type for the asynchronous message exchange and the `HoverParams` and `Hover` types which correspond to the https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_hover[LSP types of the hover specification].
<2> The actual work is performed in the `HoverService` class.

As a consequence, we do not need to worry about correctly creating a JSON-RPC message and the asynchronous complexity of the message exchange. Instead, we just use the types provided by LSP4J.

== Frege Compiler
The Frege compiler contains all possible information for the Frege language features. Extracting the needed language feature and transforming it to an LSP type is the core task of the Frege IDE. Therefore, we want to summarize the general core concept of the Frege compiler here.

== Frege and Java
We use Java for LSP4J only and Frege for everything else. See xref:principles.adoc[Principles] and xref:software-architecture.adoc[Software Architecture] for more information.



