ifdef::env-vscode[:imagesdir: ../assets/images]
:xrefstyle: short
= Code

In this Section, we want to examine how the xref:principles.adoc#funcCore[functional core, outer shell] design pattern was implemented for the hover feature with the following three steps:

Impure Input:: Compile Frege source code, extract and save the compiler global.
Pure Core:: Extract the hover information (type signature) from the extracted compiler global and transform it to the LSP hover type.
Impure Output:: Send the hover lsp data type back to the text editor using the LSP4J library.

[NOTE]
====
The xref:principles.adoc#funcCore[functional core, outer shell] design pattern generalises well:
The code for the impure input is already implemented while the code skeleton for the impure output is given by the LSP4J library. As a result, only the pure core part needs a lot of effort to implement for new language features.
====

== Impure Input

The compile component is responsible for creating an in-memory model of all available compiler information. It uses a Java `uriGlobals HashMap<URI, Global>` data structure to keep track of all openend Frege files in the text editor and its compiler information.

The Uniform Resource Identifier (`URI`) for each Frege file is defined by the https://microsoft.github.io/language-server-protocol/specifications/specification-3-16/#uri[language server protocol (LSP)], while the `Global` data type is defined by the Frege compiler. It stores all compiler information for the associated Frege file `URI` and is documented https://github.com/Frege/frege/blob/master/frege/compiler/types/Global.fr[here].

<<compile-component-seq>> shows the sequence diagram for the compile component.  


.A code change in the text editor calls the LSP component, which delegates the call to the Compile component. The Compile component compiles the given Frege file `URI` with the initialised projectGlobal and saves all returned newGlobals in the `uriGlobals` hashmap.
[seqdiag#compile-component-seq]
....
seqdiag {
    edge_length = 300;
    default_fontsize = 24;
    "Frege Language Extension" [ width = 330 ];
    "LSP"                      [ width = 60  ];
    "Compile"                  [ width = 120 ];
    "Frege Compiler"           [ width = 192 ];
    "Frege Language Extension" ->> "LSP"                 [ label = "code change in uri" ];
    "LSP"                      ->> "Compile"             [ label = "code change in uri" ];
    "Compile"                  ->> "Frege Compiler"      [ label = "compileAndUpdateGlobals\n(uri, projectGlobal)" ];
    "Compile"                  <<- "Frege Compiler"      [ label = "List<Global>\nnewGlobals" ];
    "Compile"                   -> "Compile"             [ label = "update\nuriGlobals"];
}
....

The Compile component is layered according to the xref:principles.adoc#fregeCore[Write Core Logic in Frege, Use Java for LSP] principle and shown in <<compile-layer-seq>>.

.Compile layers: The `CompileService.java` class calls the `CompileExecutorLSP.fr` module, which calls the `CompileMakeMode.fr` module. The `CompileMakeMode.fr` is the core part, which calls the Frege compiler to compile the Frege file with the given project global. The returned list of globals is of type `IO` and thus impure. This `IO [Global]` list is then first converted by the `CompileMakeMode.fr` to `IOMutalbe (ArrayList Global)` and finally to the Java native type `List<TGlobal>` As a final step the `uriGlobals` hashmap is upated with the new globals.
[seqdiag#compile-layer-seq]
....
seqdiag {
    edge_length = 280;
    default_fontsize = 24;
    "CompileService.java"    [ width = 290  ];
    "CompileExecutorLSP.fr"  [ width = 300  ];
    "CompileMakeMode.fr"     [ width = 280  ];
    "Frege Compiler"          [ width = 192  ];
    "CompileService.java" ->> "CompileService.java" [ leftnote = "compileAndUpdateGlobals\n(uri, projectGlobal)" ];
    "CompileService.java" ->> "CompileExecutorLSP.fr" [ label = "compileWithMakeMode\n(uri, projectGlobal)" ];
    "CompileExecutorLSP.fr" ->> "CompileMakeMode.fr"  [ label = "compileMakeLSP\n:: String\n-> Global\n -> IOMutable (ArrayList Global)" ];
    "CompileMakeMode.fr"    ->> "Frege Compiler"      [ label = "compileMake\n:: String\n-> Global\n -> IO [Global]" ];
    "CompileMakeMode.fr"    <<- "Frege Compiler"      [ label = "IO [Global]" ];
    "CompileExecutorLSP.fr" <<- "CompileMakeMode.fr" [ label = "IOMutable (ArrayList Global)" ];
    "CompileService.java"   <<- "CompileExecutorLSP.fr" [ label = "List<TGlobal>" ];
    "CompileService.java"    -> "CompileService.java" [ label = "update\nuriGlobals" ];
}
....

The impure `compileMake {two-colons} String -> Global -> IO [Global]` is the core function. It uses a slight variation of the Frege compiler's https://github.com/Frege/frege/wiki/Compiler-Manpage#make-mode[make mode], which automatically compiles all dependent modules first. It differs only in the return type by always returning a list of globals. For this to work, the Frege compiler needs to know the common Frege main source directory, which is configured through the project global and retrieved by the xref:software-architecture.adoc#_frege_language_server[Project component]. This builds the basis to make the Frege IDE workspace/project-aware and satisfy the usability quality attribute.

[NOTE]
.The three `Global monads in the Frege compiler`
====
.The three `Global monads` in the Frege comiler. The `StG` is pure, while the `StIO Global` and `IO Global` are impure, beautifully showing the separation of concerns. We can switch from the `StG` to the `StIO Global` monad with the `liftStG` function and from `StIO Global` to `IO Global` with the `evalStateT` function. There also exist the two convenient get global state functions getST for `StG` and `getSTT` for `StIO Global`.
[blockdiag#diag-global-monads,diag-global-monads,svg]
....
blockdiag {
    orientation = portrait;
    default_fontsize = 24;
    span_height = 80;
    "StG"                          [ width = 250 ];
    "StIO Global"                  [ width = 300 ];
    "IO Global"                    [ width = 250 ];
    "StIO Global" <- "StG"         [ label = "liftStG" ];
    "IO Global"   <- "StIO Global" [ label = "evalStateT" ];
}
....
====

== Pure Hover Core

<<hover-component-seq>> shows the sequence diagram for the hover component.  


.Hovering over an expression in the text editor calls the LSP component, which finds the global for the Frege file and delegates the call to the Hover component. The Hover component extracts the type signature from the global, transforms it to the LSP type Hover and returns it to the LSP, which forwards it back to the text editor.
[seqdiag#hover-component-seq]
....
seqdiag {
    edge_length = 350;
    default_fontsize = 24;
    "Frege Language Extension" [ width = 330 ];
    "LSP"                      [ width = 60  ];
    "Hover"                    [ width = 120 ];
    "Frege Language Extension" -> "LSP"    [ label = "hover request" ];
    "LSP"                      -> "Hover"  [ label = "hover\n(hoverParams, global)" ];
    "LSP"                      <- "Hover"  [ label = "Hover" ];
    "Frege Language Extension" <- "LSP"    [ label = "Hover" ];
}
....

The Hover component is layered according to the xref:principles.adoc#fregeCore[Write Core Logic in Frege, Use Java for LSP] principle and shown in <<hover-layers-seq>>.


.Hover layers: The `HoverService.java` class creates the Frege `PositionLSP` type and calls the `HoverLSP.fr` module. The `HoverLSP.fr` module converts the `PositionLSP` type to the core `Position` type to make the core logic data types independent of the LSP types. It then calls the `Hover.fr` module to compute the type signature, which is returned as `Maybe Hover` signaling that there may be no available type for the requested hover expression. As a final step the core data type `Maybe Hover` is transformed back to the `Maybe HoverLSP` type and returned to the `HoverService.java` class. The whole interaction is pure because there is no `IO` involved. 
[seqdiag#hover-layers-seq]
....
seqdiag {
    edge_length = 280;
    default_fontsize = 24;
    "HoverService.java"    [ width = 290  ];
    "HoverLSP.fr"          [ width = 300  ];
    "Hover.fr"             [ width = 280  ];
    "HoverService.java" -> "HoverLSP.fr" [ label = "getTypeSignatureOnHoverLSP\n:: PositionLSP\n-> Global\n -> Maybe HoverLSP" ];
    "HoverLSP.fr"       -> "Hover.fr"    [ label = "getTypeSignatureOnHover\n:: Position\n-> Global\n -> Maybe Hover" ];
    "Hover.fr"          -> "Hover.fr"    [ label = "getTypeOnHover", fontsize = "22" ];
    "HoverLSP.fr"       <- "Hover.fr"    [ label = "Maybe Hover" ];
    "HoverService.java" <- "HoverLSP.fr" [ label = "Maybe HoverLSP" ];
}
....

The `getTypeOnHover` function is responsible for the main work and is shown in <<code-getTypeOnHover>>.

.The `getTypeOnHover` Function
[source#code-getTypeOnHover,haskell]
----
getTypeOnHover :: Position -> MaybeT RGlobal Hover // <1>
getTypeOnHover pos = do
    token      <- findToken pos // <2>
    qname      <- tokenToQName token // <2>
    symbol     <- findSymbol qname // <2>
    symbolType <- lift $ getSymbolType symbol // <2>
    pure        $ Hover // <3>
        { 
            range   = tokenToRange token, 
            content = FregeCodeBlock symbolType
        }
----
<1> The function uses the monad transformer concept to combine the `Maybe Hover` (to account for no available type signature) and the `Reader Global` (the read-only `Global` record from the impure input phase) monads.
<2> The main logic: We find the needed type in the big `Global` record by moving from `token -> qualifiedName -> symbol -> symbolType`.
<3> As a last step, we transform the result to our core data type `Hover`.

Since the core is pure and since we developed it with a xref:principles.adoc#_test_driven_development[Test-Driven Development] approach it is testable as shown in <<code-hover-test>>.

.A Hover test case checking the type signature of a string constant
[source#code-hover-test,haskell]
----
shouldShowLocalVaridTypeSignature :: Property
shouldShowLocalVaridTypeSignature = once $ morallyDubiousIOProperty do // <1>
    fregeHoverCode  = "module HoverTest where\n\n" 
                   ++ "simplyString = \"Hello\""
    global         <- standardCompileGlobal
    compiledGlobal <- compile fregeHoverCode global
    expected        = Just Hover 
        { 
            range   = Range { start = Position 3 1, end = Position 3 13 },
            content = FregeCodeBlock "simplyString :: String"
        }
    actual          = getTypeSignatureOnHover (Position 3 3) compiledGlobal
    pure            $ expected == actual
----
<1> The acute reader might notice the `morallyDubiousIOProperty` and think that the test is not pure. You are right: For the test setup we need to compile the code first, which is as illustrated the impure first step. Since a pure function cannot call an impure function in Frege, we need to execute the whole test in the impure `IO` context. The `getTypeOnHover` function, however, remains pure.

== Impure Output

This last step is delegated to the https://github.com/eclipse/lsp4j[LSP4J] library. As a result, we just follow the guidelines and implement the hover binding as shown in xref:constraints.adoc#lsp4j[Constraints].